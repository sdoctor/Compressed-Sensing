% one_run.m
clc;
clear;
 
 p=0;
 M2=64;
 N=64;
 P=17;
 Q=17;
 L=randn(M2,N,P,Q);
 
%  
%  L=zeros(M2,N,P,Q);
% for i=1:P
%     for j=1:Q
%         m=p;
%         if rem(m,17)== 0
%             m =m+1;
%         else
%             a=1;
%         end
%         
% eval(['z=double(imread(''C:\Users\Rohit\Desktop\Chess LF\00 (' num2str(m) ').png''));']);
%        
% eval(['L(:,:,i,j)=z(21:20+M2,907:906+N,2);']);
% 
% p=p+1;
%     end
% end

[M2 N P Q] = size(L);
 
 W=dct4(L);
 d=W(:); 
 
 xs=d(:); 
 
 
 fraction=zeros(1,16);
 for z=2
% set up the run
n = M2*N*P*Q;
delta =1/(z);            % m/n, m = round(delta*n)
rho = 0.2;              % k/m, k = round(rho*m)
Ameth = 5;              % see getData.m for codes
xmeth = 0;              %  "      "      "    "
opts = fpc_opts([]);    % see fpc_opts.m for options
sig1 = 0.01;            % std. dev. of signal noise
sig2 = 0.01;            %  "    "   "  measurement noise
full = true;           % whether to use a full or approximate M matrix
opts.fullMu = false;    % if false, just update mu as opts.eta*mu
mu = [];                % mu to use--[] means recommended
sig1est = sig1;         % estimate of sig1 used by getM_mu
sig2est = sig2;         %    "     "  sig2  "   "    "
alpha = 0.5;            % parameter for chi^2 value
nseMult = 3;            % in debias: nse = nseMult*sigma

% plots
xsConvergence = true;
paretoPlot = true;
paretoPlotPlusProgress = true;

% problem size
m = round(delta*n);
k = round(rho*m);

% get problem
data_t = cputime;
[A,b,xs,xsn,picks] = getData(m,n,k,Ameth,xmeth,d,sig1,sig2,1978);

bwant=b;
data_t = cputime - data_t;
disp([num2str(data_t),' s to get the problem.']);

Mmu_t = cputime;
Ameth=0; % A = randn(m,n);
[M,mu,A,b,sig,kap,tau,M12] = getM_mu(full,mu,m,n,Ameth,b,sig1est,sig2est,alpha);
b=bwant;
if ~isempty(M), A = M12*A; b = M12*b; M = []; end
if ~isempty(tau), opts.tau = tau; end
opts.kappa = kap;
Mmu_t = cputime - Mmu_t;
disp([num2str(Mmu_t),' s to estimate M and mu.']);

opts.xs = xs;

% fpc-basic
solve_t = cputime;
% Use function handle
%z=@findingyAx;
%Out = fpc(n,z(I),b,mu,M,opts,picks);

Out = fpc(n,A,b,mu,M,opts,picks);
solve_t = cputime - solve_t;
disp([num2str(Out.itr),' iterations and ',num2str(solve_t),...
    ' s to solve the problem to rel. err. ',num2str(Out.n2re(end),'%5.3g'),...
    ' w/ fpc-basic.']);

% de-bias the solution
db_t = cputime;
nse = nseMult*sig;
x = debias(m,n,Out.x,A,b,M,nse,picks);
db_t = cputime - db_t;
n2re_db = norm(x - xs)/norm(xs);
disp([num2str(db_t),' s to de-bias.  Resulting rel. err. is ',...
    num2str(n2re_db),'.']);

SNRspat(z)=norm(xs,2)/norm(x-xs,2)
SNRspatdb(z)=20*log10(SNRspat(z)) 
fraction(z)=z;


dctrecover=x;

Dback=reshape(dctrecover,[M2 N P Q]);

LFback=idct4(Dback);

% 
% % Tiling orig
% tilingorig=zeros(M2*P,N*Q);
% 
% for i=1:P
%     for j=1:Q
%     tilingorig(M2*(i-1)+1:M2*i,N*(j-1)+1:N*j)=uint8(I(:,:,i,j));
%     end
% end
% 
% figure,
% imagesc(tilingorig);
% colormap gray;
% xlabel('Original LF tiles size: 32-32-8-8');
% 
% 
% 
 %Tiling back
tilingback=zeros(M*P,N*Q);

for i=1:P
    for j=1:Q
    tilingback(M2*(i-1)+1:M2*i,N*(j-1)+1:N*j)=uint8(LFback(:,:,i,j));
    end
end
tilingback=uint8(tilingback);
eval(['imwrite(uint8(tilingback),''ROHITCompressiveInvNbyMfactor' num2str(z) '.png'');']);
check='written'

%%%%%%%%%%%%ANGULAR INFO ANALYSIS


LFsqorig = squeeze(I);

for i=1:M
    for j=1:N
        LFnewtileorig((i-1)*P+1:(i-1)*P+P,(j-1)*Q+1:(j-1)*Q+Q)=LFsqorig(i,j,:,:);
    end
end

eval(['imwrite(uint8(LFnewtileorig),''RangularORIG.png'');']);

LFbacksqr = squeeze(LFback);

for i=1:M
    for j=1:N
        LFnewtiler((i-1)*P+1:(i-1)*P+P,(j-1)*Q+1:(j-1)*Q+Q)=LFbacksqr(i,j,:,:);
    end
end

eval(['imwrite(uint8(LFnewtiler),''RangularReCONSTRfraction' num2str(z) '.png'');']);

for i=1:P
    for j=1:Q
        origmean((i-1)*M+1:(i-1)*M+M,(j-1)*N+1:(j-1)*N+N) = mean(mean(LFnewtileorig((i-1)*M+1:(i-1)*M+M,(j-1)*N+1:(j-1)*N+N)));
    end
end



for i=1:P
    for j=1:Q
        rmean((i-1)*M+1:(i-1)*M+M,(j-1)*N+1:(j-1)*N+N) = mean(mean(LFnewtiler((i-1)*M+1:(i-1)*M+M,(j-1)*N+1:(j-1)*N+N)));
    end
end


anginfoorig = LFnewtileorig-origmean;
anginfor= LFnewtiler-rmean;


SNRang(z) = norm(anginfoorig,2)/norm( anginfoorig-anginfor,2)

SNRangdb(z) = 20*log10(SNRang(z))


 end

 SNRspatdb(1)= 0;
 SNRangdb(1) = 0;
 save SNRspat SNRspatdb SNRang SNRangdb
figure; plot(SNRspatdb,'+');  
xlabel('1/z where z decides M=N/z');
ylabel('SNR levels in db for SPAT');

figure; plot(SNRangdb,'*');  
xlabel('1/z where z decides M=N/z');
ylabel('SNR levels in db for ANG');


figure; 
plot(SNRspatdb,'+');
hold all;
plot(SNRangdb,'*'); 
xlabel('1/z where z decides M=N/z');
ylabel('SNR levels in db for SPAT & ANG');
legend('SPAT','ANG');

 